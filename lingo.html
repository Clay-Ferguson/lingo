<!DOCTYPE html>
<html lang="en"> 
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TTS Reader â€” Read selection or full text</title>
  <style>
    :root {
      --bg: #1a1a1a;
      --panel: #2a2a2a;
      --textarea-bg: #333333;
      --muted: #999;
      --text-primary: #e0e0e0;
      --text-secondary: #ccc;
      --accent: #4a9eff;
      --border: #444;
      --gap: 10px;
    }
    html,body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: var(--bg);
      color: var(--text-primary);
      overflow: hidden;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    .topbar {
      display: flex;
      gap: var(--gap);
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
    }

    .app-name {
      font-size: 30px;
      font-weight: bold;
      color: var(--accent);
      /* margin-right: 16px; */
      user-select: none;
    }

    .controls-left {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .tts-panel {
      display: flex;
      gap: 8px;
      align-items: center;
      border: 2px solid var(--accent);
      background: rgba(74, 158, 255, 0.08);
      border-radius: 12px;
      padding: 5px 8px;
      margin-left: 12px;
      box-shadow: 0 2px 8px 0 rgba(74,158,255,0.04);
    }

    @media (max-width: 640px) {
      .tts-panel {
        flex-direction: column;
        gap: 6px;
        margin-left: 0;
        width: 100%;
      }
    }

    button {
      border: 1px solid #2563eb;
      background: #2563eb;
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: background-color 0.2s, border-color 0.2s;
    }

    button:hover:not(:disabled) {
      background: #1d4ed8;
      border-color: #1d4ed8;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .listening {
      background: #2563eb !important;
      border-color: #2563eb !important;
      color: white !important;
    }

    .listening:hover {
      background: #1d4ed8 !important;
      border-color: #1d4ed8 !important;
    }

    .selects {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-left: 8px;
    }

    select {
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #2563eb;
      background: var(--panel);
      color: var(--text-primary);
      min-width: 160px;
    }

    select:focus {
      outline: none;
      border-color: #1d4ed8;
    }

    .status {
      margin-left: auto;
      color: var(--muted);
      font-size: 14px;
    }

    .container {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 0 16px 16px 16px;
      box-sizing: border-box;
      overflow: hidden;
    }

    textarea {
      flex: 1;
      width: 100%;
      box-sizing: border-box;
      padding: 14px;
      border: 2px solid #4a9eff;
      resize: none;
      font-size: 16px;
      line-height: 1.45;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Segoe UI Mono", monospace;
      outline: none;
      background: var(--textarea-bg);
      color: var(--text-secondary);
      min-height: 0;
    }

    textarea::placeholder {
      color: var(--muted);
    }

    textarea:focus {
      background: #3a3a3a;
    }

    .listening-textarea {
      border-color: #dc2626 !important;
      box-shadow: 0 0 0 2px rgba(220, 38, 38, 0.3);
    }

    .hint {
      font-size: 13px;
      color: var(--muted);
      padding: 8px 12px;
      background: var(--panel);
      border-top: 1px solid var(--border);
    }

    @media (max-width: 640px) {
      .selects { flex-direction: column; gap: 6px; margin-left: 0; }
      select { min-width: 140px; }
    }
  </style>
</head>
<body>
  <div class="topbar" role="region" aria-label="TTS controls">
    <div class="app-name">Lingo</div>
    <div class="controls-left">
      <div class="tts-panel">
        <button id="readBtn" title="Read selection or full text (Ctrl/Cmd+Enter)">ðŸ”Š Read Aloud</button>
        <div class="selects" aria-hidden="false">
          <label for="voiceSelect" style="display:none">Voice</label>
          <select id="voiceSelect" aria-label="Choose voice"></select>

          <label for="rateSelect" style="display:none">Speed</label>
          <select id="rateSelect" aria-label="Choose speaking speed">
            <option value="0.85">0.85 â€” Slow</option>
            <option value="1" selected>1.0 â€” Normal</option>
            <option value="1.15">1.15 â€” Faster</option>
            <option value="1.25">1.25 â€” Fastest</option>
            <option value="1.3">1.35 â€” Ludicrous</option>
          </select>
        </div>
      </div>
      <button id="micBtn" title="Start/Stop Speech Recognition (Ctrl/Cmd+M)">ðŸŽ¤ Mic Dictation</button>
    </div>
    <div class="status" id="status">Ready</div>
  </div>

  <div class="container">
    <textarea id="text" placeholder="Type or paste text here... (select part of this text to read just the selection)"></textarea>
  </div>

  <script>
    const readBtn = document.getElementById("readBtn");
    const micBtn = document.getElementById("micBtn");
    const voiceSelect = document.getElementById("voiceSelect");
    const rateSelect = document.getElementById("rateSelect");
    const textArea = document.getElementById("text");
    const status = document.getElementById("status");

    const STORAGE_VOICE_KEY = "tts_selected_voice_name_v1";
    const STORAGE_RATE_KEY = "tts_selected_rate_v1";

    let currentUtterance = null;
    let isTTSSpeaking = false;
    
    // Speech Recognition variables
    let recognition = null;
    let isListening = false;
    let shouldKeepListening = false;

    function supportsSpeech() {
      return "speechSynthesis" in window && typeof SpeechSynthesisUtterance !== "undefined";
    }

    function supportsSpeechRecognition() {
      return "webkitSpeechRecognition" in window;
    }

    function setStatus(text) {
      status.textContent = text || "";
    }

    function updateReadButton() {
      if (isTTSSpeaking) {
        readBtn.textContent = "â¹ï¸ Stop";
        readBtn.title = "Stop speaking (Esc)";
        readBtn.disabled = false;
      } else {
        readBtn.textContent = "ðŸ”Š Read Aloud";
        readBtn.title = "Read selection or full text (Ctrl/Cmd+Enter)";
        // Disable read button when speech recognition is active
        readBtn.disabled = shouldKeepListening;
      }
    }

    function updateMicButton() {
      if (shouldKeepListening) {
        micBtn.classList.add('listening');
        micBtn.textContent = 'â¹ï¸ Stop';
        micBtn.disabled = false;
      } else {
        micBtn.classList.remove('listening');
        micBtn.textContent = 'ðŸŽ¤ Mic Dictation';
        // Disable mic button when TTS is speaking
        micBtn.disabled = isTTSSpeaking;
      }
    }

    function populateVoices() {
      const voices = window.speechSynthesis.getVoices() || [];
      
      // If no voices available yet, try again later
      if (voices.length === 0) {
        setTimeout(populateVoices, 100);
        return;
      }

      voiceSelect.innerHTML = "";

      voices.forEach((v, i) => {
        const option = document.createElement("option");
        option.value = v.name;
        option.textContent = `${v.name} (${v.lang})${v.default ? " â€” default" : ""}`;
        option.dataset.lang = v.lang;
        voiceSelect.appendChild(option);
      });

      // restore saved voice if present
      const saved = localStorage.getItem(STORAGE_VOICE_KEY);
      if (saved) {
        const found = Array.from(voiceSelect.options).find(o => o.value === saved);
        if (found) {
          voiceSelect.value = saved;
        }
      }

      // If nothing selected, pick the default voice or first
      if (!voiceSelect.value && voiceSelect.options.length) {
        const defaultIndex = Array.from(voiceSelect.options).findIndex(o => o.textContent.includes("â€” default"));
        voiceSelect.selectedIndex = defaultIndex >= 0 ? defaultIndex : 0;
      }

      // restore rate
      const savedRate = localStorage.getItem(STORAGE_RATE_KEY);
      if (savedRate) {
        rateSelect.value = savedRate;
      }
    }

    function savePreferences() {
      try {
        localStorage.setItem(STORAGE_VOICE_KEY, voiceSelect.value);
        localStorage.setItem(STORAGE_RATE_KEY, rateSelect.value);
      } catch (e) {
        // ignore storage errors
      }
    }

    function speakText(text) {
      if (!text || !text.trim()) {
        setStatus("Nothing to read");
        return;
      }

      if (!supportsSpeech()) {
        setStatus("Browser does not support the Web Speech API.");
        return;
      }

      // Stop speech recognition if it's active
      if (shouldKeepListening) {
        shouldKeepListening = false;
        if (recognition) {
          try {
            recognition.stop();
          } catch (error) {
            console.error('Error stopping speech recognition:', error);
          }
        }
        // Update mic button state immediately
        isListening = false;
        micBtn.classList.remove('listening');
        micBtn.textContent = 'ðŸŽ¤ Mic Dictation';
        textArea.classList.remove('listening-textarea');
        updateMicButton();
      }

      // Cancel any current speech
      window.speechSynthesis.cancel();

      // Wait a moment for cancel to complete
      setTimeout(() => {
        const utter = new SpeechSynthesisUtterance(text.trim());
        const voices = window.speechSynthesis.getVoices() || [];

        // If no voices available, try to trigger voice loading
        if (voices.length === 0) {
          // Force voice loading by speaking empty text first
          const tempUtter = new SpeechSynthesisUtterance("");
          window.speechSynthesis.speak(tempUtter);
          window.speechSynthesis.cancel();
          
          // Retry after a moment
          setTimeout(() => speakText(text), 200);
          return;
        }

        // prefer exact match by name; fallback to currently selected index
        const chosenName = voiceSelect.value;
        const chosenVoice = voices.find(v => v.name === chosenName) || voices[voiceSelect.selectedIndex] || null;
        if (chosenVoice) {
          utter.voice = chosenVoice;
        }

        utter.rate = parseFloat(rateSelect.value) || 1.0;
        utter.pitch = 1.0;
        utter.volume = 1.0;

        utter.onstart = () => {
          currentUtterance = utter;
          isTTSSpeaking = true;
          setStatus("Speaking...");
          updateReadButton();
          updateMicButton();
        };

        utter.onend = () => {
          currentUtterance = null;
          isTTSSpeaking = false;
          setStatus("Done");
          updateReadButton();
          updateMicButton();
        };

        utter.onerror = (evt) => {
          currentUtterance = null;
          isTTSSpeaking = false;
          setStatus("Error during speech: " + (evt.error || "Unknown error"));
          console.error("Speech error:", evt);
          updateReadButton();
          updateMicButton();
        };

        try {
          window.speechSynthesis.speak(utter);
        } catch (e) {
          setStatus("Error: " + e.message);
          console.error("Speech synthesis error:", e);
          isTTSSpeaking = false;
          updateReadButton();
          updateMicButton();
        }
      }, 100);
    }

    // event handlers
    readBtn.addEventListener("click", () => {
      if (isTTSSpeaking) {
        // Stop TTS
        if (supportsSpeech()) {
          window.speechSynthesis.cancel();
          setStatus("Stopped");
        }
        currentUtterance = null;
        isTTSSpeaking = false;
        updateReadButton();
        updateMicButton();
      } else {
        // Start TTS
        const selStart = textArea.selectionStart;
        const selEnd = textArea.selectionEnd;
        const selectedText = (selStart !== undefined && selEnd !== undefined && selEnd > selStart)
          ? textArea.value.substring(selStart, selEnd)
          : "";
        const textToRead = selectedText.trim() ? selectedText : textArea.value;
        speakText(textToRead);
      }
    });

    voiceSelect.addEventListener("change", () => {
      savePreferences();
    });

    rateSelect.addEventListener("change", () => {
      savePreferences();
    });

    // Speech Recognition Functions
    function initializeSpeechRecognition() {
      if (!supportsSpeechRecognition()) {
        console.warn('Speech recognition not supported in this browser');
        micBtn.disabled = true;
        micBtn.title = "Speech recognition not supported in this browser";
        return;
      }

      recognition = new webkitSpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = false;
      recognition.lang = 'en-US';

      recognition.onstart = () => {
        isListening = true;
        micBtn.classList.add('listening');
        micBtn.textContent = 'â¹ï¸ Stop';
        textArea.classList.add('listening-textarea');
        setStatus("Listening...");
        updateReadButton();
        updateMicButton();
      };

      recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        setStatus(`Speech error: ${event.error}`);
      };

      recognition.onend = () => {
        isListening = false;
        micBtn.classList.remove('listening');
        micBtn.textContent = 'ðŸŽ¤ Mic Dictation';
        textArea.classList.remove('listening-textarea');
        
        if (shouldKeepListening) {
          // Auto-restart if we should keep listening
          try {
            recognition.start();
          } catch (error) {
            console.error('Error restarting speech recognition:', error);
            shouldKeepListening = false;
            setStatus("Speech recognition stopped");
            updateReadButton();
            updateMicButton();
          }
        } else {
          setStatus("Speech recognition stopped");
          updateReadButton();
          updateMicButton();
        }
      };

      recognition.onresult = (event) => {
        for (let i = event.resultIndex; i < event.results.length; ++i) {
          if (event.results[i].isFinal) {
            const transcript = event.results[i][0].transcript.trim();
            
            if (transcript) {
              insertTextAtCursor(transcript + ' ');
            }
          }
        }
      };
    }

    function insertTextAtCursor(text) {
      const cursorPosition = textArea.selectionStart;
      const selectionEnd = textArea.selectionEnd;
      const currentContent = textArea.value;
      
      // Insert text at cursor position, replacing any selected text
      const beforeCursor = currentContent.substring(0, cursorPosition);
      const afterCursor = currentContent.substring(selectionEnd);
      
      const newContent = beforeCursor + text + afterCursor;
      textArea.value = newContent;
      
      // Set cursor position after the inserted text
      const newCursorPosition = cursorPosition + text.length;
      textArea.setSelectionRange(newCursorPosition, newCursorPosition);
      textArea.focus();
    }

    function toggleSpeechRecognition() {
      if (!supportsSpeechRecognition()) {
        setStatus("Speech recognition is not supported in this browser. Please use Google Chrome.");
        return;
      }

      if (!recognition) {
        initializeSpeechRecognition();
        if (!recognition) return;
      }

      if (shouldKeepListening) {
        // Stop listening
        shouldKeepListening = false;
        try {
          recognition.stop();
        } catch (error) {
          console.error('Error stopping speech recognition:', error);
        }
      } else {
        // Stop TTS if it's active before starting speech recognition
        if (isTTSSpeaking) {
          if (supportsSpeech()) {
            window.speechSynthesis.cancel();
          }
          currentUtterance = null;
          isTTSSpeaking = false;
          updateReadButton();
          updateMicButton();
        }

        // Start listening
        shouldKeepListening = true;
        try {
          recognition.start();
        } catch (error) {
          console.error('Error starting speech recognition:', error);
          shouldKeepListening = false;
          setStatus(`Error starting speech recognition: ${error.message}`);
        }
      }
    }

    // Speech Recognition button event
    micBtn.addEventListener("click", toggleSpeechRecognition);

    // keyboard shortcuts while textarea focused
    textArea.addEventListener("keydown", (evt) => {
      if ((evt.ctrlKey || evt.metaKey) && evt.key === "Enter") {
        evt.preventDefault();
        readBtn.click();
        return;
      }
      if (evt.key === "Escape") {
        evt.preventDefault();
        if (shouldKeepListening) {
          micBtn.click(); // Stop speech recognition first
        } else if (isTTSSpeaking) {
          readBtn.click(); // Stop TTS
        }
        return;
      }
      if ((evt.ctrlKey || evt.metaKey) && evt.key.toLowerCase() === "m") {
        evt.preventDefault();
        micBtn.click();
        return;
      }
    });

    // initial setup
    if (!supportsSpeech()) {
      setStatus("Web Speech API not supported in this browser. Use Chrome/Chromium for best results.");
      readBtn.disabled = true;
    } else {
      setStatus("Loading voices...");
      // populate voices (some browsers require async wait)
      populateVoices();
      // Many browsers fire an event when voices change
      window.speechSynthesis.onvoiceschanged = () => {
        populateVoices();
        setStatus("Ready");
      };
      // call again after a short delay in case voices arrive
      setTimeout(() => {
        populateVoices();
        setStatus("Ready");
      }, 250);
    }

    // Initialize speech recognition
    initializeSpeechRecognition();

    // restore textarea content or focus
    textArea.focus();

    // Expose some helpers to console for debugging if needed (handy during development)
    window.__tts = {
      speakNow: (txt) => speakText(String(txt)),
      cancel: () => { if (supportsSpeech()) window.speechSynthesis.cancel(); }
    };
  </script>
</body>
</html>
