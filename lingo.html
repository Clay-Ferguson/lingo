<!DOCTYPE html>
<html lang="en"> 
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TTS Reader ‚Äî Read selection or full text</title>
  <style>
    :root {
      --bg: #1a1a1a;
      --panel: #2a2a2a;
      --textarea-bg: #333333;
      --muted: #999;
      --text-primary: #e0e0e0;
      --text-secondary: #ccc;
      --accent: #4a9eff;
      --border: #444;
      --gap: 10px;
    }
    html,body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: var(--bg);
      color: var(--text-primary);
      overflow: hidden;
    }

    body {
      display: flex;
      flex-direction: column;
    }

    .topbar {
      display: flex;
      gap: var(--gap);
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
    }

    .app-name {
      font-size: 30px;
      font-weight: bold;
      color: var(--accent);
      /* margin-right: 16px; */
      user-select: none;
    }

    .controls-left {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .tts-panel {
      display: flex;
      gap: 8px;
      align-items: center;
      border: 2px solid var(--accent);
      background: rgba(74, 158, 255, 0.08);
      border-radius: 12px;
      padding: 5px 8px;
      margin-left: 12px;
      box-shadow: 0 2px 8px 0 rgba(74,158,255,0.04);
    }

    @media (max-width: 640px) {
      .tts-panel {
        flex-direction: column;
        gap: 6px;
        margin-left: 0;
        width: 100%;
      }
    }

    button {
      border: 1px solid #2563eb;
      background: #2563eb;
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: background-color 0.2s, border-color 0.2s;
    }

    button:hover:not(:disabled) {
      background: #1d4ed8;
      border-color: #1d4ed8;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .listening {
      background: #2563eb !important;
      border-color: #2563eb !important;
      color: white !important;
    }

    .listening:hover {
      background: #1d4ed8 !important;
      border-color: #1d4ed8 !important;
    }

    .selects {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-left: 8px;
    }

    select {
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #2563eb;
      background: var(--panel);
      color: var(--text-primary);
      min-width: 160px;
    }

    select:focus {
      outline: none;
      border-color: #1d4ed8;
    }

    .status {
      margin-left: auto;
      color: var(--muted);
      font-size: 14px;
    }

    .container {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 0 16px 16px 16px;
      box-sizing: border-box;
      overflow: hidden;
    }

    textarea {
      flex: 1;
      width: 100%;
      box-sizing: border-box;
      padding: 14px;
      border: 2px solid #4a9eff;
      resize: none;
      font-size: 16px;
      line-height: 1.45;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Segoe UI Mono", monospace;
      outline: none;
      background: var(--textarea-bg);
      color: var(--text-secondary);
      min-height: 0;
    }

    textarea::placeholder {
      color: var(--muted);
    }

    textarea:focus {
      background: #3a3a3a;
    }

    .listening-textarea {
      border-color: #dc2626 !important;
      box-shadow: 0 0 0 2px rgba(220, 38, 38, 0.3);
    }

    .hint {
      font-size: 13px;
      color: var(--muted);
      padding: 8px 12px;
      background: var(--panel);
      border-top: 1px solid var(--border);
    }

    @media (max-width: 640px) {
      .selects { flex-direction: column; gap: 6px; margin-left: 0; }
      select { min-width: 140px; }
    }
  </style>
</head>
<body>
  <div class="topbar" role="region" aria-label="TTS controls">
    <div class="app-name">Lingo</div>
    <div class="controls-left">
      <div class="tts-panel">
        <button id="readBtn" title="Read selection or full text (Ctrl/Cmd+Enter)">üîä Read</button>
        <button id="stopBtn" style="display:none" title="Stop speaking (Esc)">‚èπÔ∏è Stop</button>
        <button id="pauseBtn" style="display:none" title="Pause speaking">‚è∏Ô∏è Pause</button>
        <button id="resumeBtn" style="display:none" title="Resume speaking">‚ñ∂Ô∏è Resume</button>
        <div class="selects" aria-hidden="false">
          <label for="voiceSelect" style="display:none">Voice</label>
          <select id="voiceSelect" aria-label="Choose voice"></select>

          <label for="rateSelect" style="display:none">Speed</label>
          <select id="rateSelect" aria-label="Choose speaking speed">
            <option value="0.85">0.85 ‚Äî Slow</option>
            <option value="1" selected>1.0 ‚Äî Normal</option>
            <option value="1.15">1.15 ‚Äî Faster</option>
            <option value="1.25">1.25 ‚Äî Fastest</option>
            <option value="1.3">1.35 ‚Äî Ludicrous</option>
          </select>
        </div>
      </div>
      <button id="micBtn" title="Start/Stop Speech Recognition (Ctrl/Cmd+M)">üé§ Mic</button>
      <button id="copyBtn" title="Copy text to clipboard">üìã Copy</button>
      <button id="clearBtn" title="Clear all text">üóëÔ∏è Clear</button>
    </div>
    <div class="status" id="status">Ready</div>
  </div>

  <div class="container">
    <textarea id="text" placeholder="Type or paste text here... (select part of this text to read just the selection)"></textarea>
  </div>

  <script>
    const readBtn = document.getElementById("readBtn");
    const stopBtn = document.getElementById("stopBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const resumeBtn = document.getElementById("resumeBtn");
    const micBtn = document.getElementById("micBtn");
    const copyBtn = document.getElementById("copyBtn");
    const clearBtn = document.getElementById("clearBtn");
    const voiceSelect = document.getElementById("voiceSelect");
    const rateSelect = document.getElementById("rateSelect");
    const textArea = document.getElementById("text");
    const status = document.getElementById("status");

    const STORAGE_VOICE_KEY = "tts_selected_voice_name_v1";
    const STORAGE_RATE_KEY = "tts_selected_rate_v1";
    const STORAGE_TEXT_KEY = "tts_text_buffer_v1";

    let currentUtterance = null;
    let isTTSSpeaking = false;
    let isTTSPaused = false;
    
    // Speech Recognition variables
    let recognition = null;
    let isListening = false;
    let shouldKeepListening = false;

    function supportsSpeech() {
      return "speechSynthesis" in window && typeof SpeechSynthesisUtterance !== "undefined";
    }

    function supportsSpeechRecognition() {
      return "webkitSpeechRecognition" in window;
    }

    function setStatus(text) {
      status.textContent = text || "";
    }

    function updateReadButton() {
      if (isTTSSpeaking) {
        readBtn.style.display = "none";
        stopBtn.style.display = "";
        if (isTTSPaused) {
          pauseBtn.style.display = "none";
          resumeBtn.style.display = "";
        } else {
          pauseBtn.style.display = "";
          resumeBtn.style.display = "none";
        }
      } else {
        readBtn.style.display = "";
        stopBtn.style.display = "none";
        pauseBtn.style.display = "none";
        resumeBtn.style.display = "none";
        // Disable read button when speech recognition is active
        readBtn.disabled = shouldKeepListening;
      }
    }

    function updateMicButton() {
      if (shouldKeepListening) {
        micBtn.classList.add('listening');
        micBtn.textContent = '‚èπÔ∏è Stop';
        micBtn.disabled = false;
      } else {
        micBtn.classList.remove('listening');
        micBtn.textContent = 'üé§ Mic Dictation';
        // Disable mic button when TTS is speaking
        micBtn.disabled = isTTSSpeaking;
      }
    }

    function populateVoices() {
      const voices = window.speechSynthesis.getVoices() || [];
      
      // If no voices available yet, try again later
      if (voices.length === 0) {
        setTimeout(populateVoices, 100);
        return;
      }

      voiceSelect.innerHTML = "";

      voices.forEach((v, i) => {
        const option = document.createElement("option");
        option.value = v.name;
        option.textContent = `${v.name} (${v.lang})${v.default ? " ‚Äî default" : ""}`;
        option.dataset.lang = v.lang;
        voiceSelect.appendChild(option);
      });

      // restore saved voice if present
      const saved = localStorage.getItem(STORAGE_VOICE_KEY);
      if (saved) {
        const found = Array.from(voiceSelect.options).find(o => o.value === saved);
        if (found) {
          voiceSelect.value = saved;
        }
      }

      // If nothing selected, pick the default voice or first
      if (!voiceSelect.value && voiceSelect.options.length) {
        const defaultIndex = Array.from(voiceSelect.options).findIndex(o => o.textContent.includes("‚Äî default"));
        voiceSelect.selectedIndex = defaultIndex >= 0 ? defaultIndex : 0;
      }

      // restore rate
      const savedRate = localStorage.getItem(STORAGE_RATE_KEY);
      if (savedRate) {
        rateSelect.value = savedRate;
      }
    }

    function savePreferences() {
      try {
        localStorage.setItem(STORAGE_VOICE_KEY, voiceSelect.value);
        localStorage.setItem(STORAGE_RATE_KEY, rateSelect.value);
      } catch (e) {
        // ignore storage errors
      }
    }

    function speakText(text) {
      if (!text || !text.trim()) {
        setStatus("Nothing to read");
        return;
      }

      if (!supportsSpeech()) {
        setStatus("Browser does not support the Web Speech API.");
        return;
      }

      // Stop speech recognition if it's active
      if (shouldKeepListening) {
        shouldKeepListening = false;
        if (recognition) {
          try {
            recognition.stop();
          } catch (error) {
            console.error('Error stopping speech recognition:', error);
          }
        }
        // Update mic button state immediately
        isListening = false;
        micBtn.classList.remove('listening');
        micBtn.textContent = 'üé§ Mic';
        textArea.classList.remove('listening-textarea');
        updateMicButton();
      }

      // Cancel any current speech
      window.speechSynthesis.cancel();

      // Wait a moment for cancel to complete
      setTimeout(() => {
        const utter = new SpeechSynthesisUtterance(text.trim());
        const voices = window.speechSynthesis.getVoices() || [];

        // If no voices available, try to trigger voice loading
        if (voices.length === 0) {
          // Force voice loading by speaking empty text first
          const tempUtter = new SpeechSynthesisUtterance("");
          window.speechSynthesis.speak(tempUtter);
          window.speechSynthesis.cancel();
          
          // Retry after a moment
          setTimeout(() => speakText(text), 200);
          return;
        }

        // prefer exact match by name; fallback to currently selected index
        const chosenName = voiceSelect.value;
        const chosenVoice = voices.find(v => v.name === chosenName) || voices[voiceSelect.selectedIndex] || null;
        if (chosenVoice) {
          utter.voice = chosenVoice;
        }

        utter.rate = parseFloat(rateSelect.value) || 1.0;
        utter.pitch = 1.0;
        utter.volume = 1.0;

        utter.onstart = () => {
          currentUtterance = utter;
          isTTSSpeaking = true;
          setStatus("Speaking...");
          updateReadButton();
          updateMicButton();
        };

        utter.onend = () => {
          currentUtterance = null;
          isTTSSpeaking = false;
          isTTSPaused = false;
          setStatus("Done");
          updateReadButton();
          updateMicButton();
        };

        utter.onerror = (evt) => {
          currentUtterance = null;
          isTTSSpeaking = false;
          isTTSPaused = false;
          setStatus("Error during speech: " + (evt.error || "Unknown error"));
          console.error("Speech error:", evt);
          updateReadButton();
          updateMicButton();
        };

        try {
          window.speechSynthesis.speak(utter);
        } catch (e) {
          setStatus("Error: " + e.message);
          console.error("Speech synthesis error:", e);
          isTTSSpeaking = false;
          updateReadButton();
          updateMicButton();
        }
      }, 100);
    }

    // event handlers
    readBtn.addEventListener("click", () => {
      // Start TTS
      const selStart = textArea.selectionStart ?? 0;
      const selEnd = textArea.selectionEnd ?? 0;
      
      let textToRead;
      if (selEnd > selStart) {
        // If there's a selection, read only the selected text
        textToRead = textArea.value.substring(selStart, selEnd);
      } else {
        // Otherwise, read from cursor position to the end
        textToRead = textArea.value.substring(selStart);
        // If at the very end (nothing to read), start from the beginning
        if (!textToRead.length) {
          textToRead = textArea.value;
        }
      }
      speakText(textToRead);
    });

    stopBtn.addEventListener("click", () => {
      // Stop TTS
      if (supportsSpeech()) {
        window.speechSynthesis.cancel();
        setStatus("Stopped");
      }
      currentUtterance = null;
      isTTSSpeaking = false;
      isTTSPaused = false;
      updateReadButton();
      updateMicButton();
    });

    pauseBtn.addEventListener("click", () => {
      if (supportsSpeech() && isTTSSpeaking && !isTTSPaused) {
        window.speechSynthesis.pause();
        isTTSPaused = true;
        setStatus("Paused");
        updateReadButton();
      }
    });

    resumeBtn.addEventListener("click", () => {
      if (supportsSpeech() && isTTSSpeaking && isTTSPaused) {
        window.speechSynthesis.resume();
        isTTSPaused = false;
        setStatus("Speaking...");
        updateReadButton();
      }
    });

    voiceSelect.addEventListener("change", () => {
      savePreferences();
    });

    rateSelect.addEventListener("change", () => {
      savePreferences();
    });

    // Speech Recognition Functions
    function initializeSpeechRecognition() {
      if (!supportsSpeechRecognition()) {
        console.warn('Speech recognition not supported in this browser');
        micBtn.disabled = true;
        micBtn.title = "Speech recognition not supported in this browser";
        return;
      }

      recognition = new webkitSpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = false;
      recognition.lang = 'en-US';

      recognition.onstart = () => {
        isListening = true;
        micBtn.classList.add('listening');
        micBtn.textContent = '‚èπÔ∏è Stop';
        textArea.classList.add('listening-textarea');
        setStatus("Listening...");
        updateReadButton();
        updateMicButton();
      };

      recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        setStatus(`Speech error: ${event.error}`);
      };

      recognition.onend = () => {
        isListening = false;
        micBtn.classList.remove('listening');
        micBtn.textContent = 'üé§ Mic Dictation';
        textArea.classList.remove('listening-textarea');
        
        if (shouldKeepListening) {
          // Auto-restart if we should keep listening
          try {
            recognition.start();
          } catch (error) {
            console.error('Error restarting speech recognition:', error);
            shouldKeepListening = false;
            setStatus("Speech recognition stopped");
            updateReadButton();
            updateMicButton();
          }
        } else {
          setStatus("Speech recognition stopped");
          updateReadButton();
          updateMicButton();
        }
      };

      recognition.onresult = (event) => {
        for (let i = event.resultIndex; i < event.results.length; ++i) {
          if (event.results[i].isFinal) {
            const transcript = event.results[i][0].transcript.trim();
            
            if (transcript) {
              insertTextAtCursor(transcript + ' ');
            }
          }
        }
      };
    }

    function insertTextAtCursor(text) {
      const cursorPosition = textArea.selectionStart;
      const selectionEnd = textArea.selectionEnd;
      const currentContent = textArea.value;
      
      // Insert text at cursor position, replacing any selected text
      const beforeCursor = currentContent.substring(0, cursorPosition);
      const afterCursor = currentContent.substring(selectionEnd);
      
      const newContent = beforeCursor + text + afterCursor;
      textArea.value = newContent;
      
      // Set cursor position after the inserted text
      const newCursorPosition = cursorPosition + text.length;
      textArea.setSelectionRange(newCursorPosition, newCursorPosition);
      textArea.focus();
    }

    function toggleSpeechRecognition() {
      if (!supportsSpeechRecognition()) {
        setStatus("Speech recognition is not supported in this browser. Please use Google Chrome.");
        return;
      }

      if (!recognition) {
        initializeSpeechRecognition();
        if (!recognition) return;
      }

      if (shouldKeepListening) {
        // Stop listening
        shouldKeepListening = false;
        try {
          recognition.stop();
        } catch (error) {
          console.error('Error stopping speech recognition:', error);
        }
      } else {
        // Stop TTS if it's active before starting speech recognition
        if (isTTSSpeaking) {
          if (supportsSpeech()) {
            window.speechSynthesis.cancel();
          }
          currentUtterance = null;
          isTTSSpeaking = false;
          updateReadButton();
          updateMicButton();
        }

        // Start listening
        shouldKeepListening = true;
        try {
          recognition.start();
        } catch (error) {
          console.error('Error starting speech recognition:', error);
          shouldKeepListening = false;
          setStatus(`Error starting speech recognition: ${error.message}`);
        }
      }
    }

    // Speech Recognition button event
    micBtn.addEventListener("click", toggleSpeechRecognition);

    // Copy button event
    copyBtn.addEventListener("click", async () => {
      const text = textArea.value;
      if (!text || !text.trim()) {
        setStatus("Nothing to copy");
        return;
      }

      try {
        await navigator.clipboard.writeText(text);
        setStatus("Copied to clipboard!");
        setTimeout(() => setStatus("Ready"), 2000);
      } catch (error) {
        console.error('Copy failed:', error);
        setStatus("Failed to copy to clipboard");
        setTimeout(() => setStatus("Ready"), 2000);
      }
    });

    // Clear button event
    clearBtn.addEventListener("click", () => {
      textArea.value = "";
      textArea.focus();
      setStatus("Text cleared");
      setTimeout(() => setStatus("Ready"), 2000);
    });

    // Save text buffer when page is about to close
    window.addEventListener("beforeunload", () => {
      try {
        let textToSave = textArea.value;
        // Add divider prefix if text exists and doesn't already start with one
        if (textToSave.trim() && !textToSave.trim().startsWith('---')) {
          textToSave = '\n---\n' + textToSave;
        }
        localStorage.setItem(STORAGE_TEXT_KEY, textToSave);
      } catch (e) {
        console.error('Error saving text buffer:', e);
      }
    });

    // keyboard shortcuts while textarea focused
    textArea.addEventListener("keydown", (evt) => {
      if ((evt.ctrlKey || evt.metaKey) && evt.key === "Enter") {
        evt.preventDefault();
        readBtn.click();
        return;
      }
      if (evt.key === "Escape") {
        evt.preventDefault();
        if (shouldKeepListening) {
          micBtn.click(); // Stop speech recognition first
        } else if (isTTSSpeaking) {
          stopBtn.click(); // Stop TTS
        }
        return;
      }
      if ((evt.ctrlKey || evt.metaKey) && evt.key.toLowerCase() === "m") {
        evt.preventDefault();
        micBtn.click();
        return;
      }
    });

    // initial setup
    if (!supportsSpeech()) {
      setStatus("Web Speech API not supported in this browser. Use Chrome/Chromium for best results.");
      readBtn.disabled = true;
    } else {
      setStatus("Loading voices...");
      // populate voices (some browsers require async wait)
      populateVoices();
      // Many browsers fire an event when voices change
      window.speechSynthesis.onvoiceschanged = () => {
        populateVoices();
        setStatus("Ready");
      };
      // call again after a short delay in case voices arrive
      setTimeout(() => {
        populateVoices();
        setStatus("Ready");
      }, 250);
    }

    // Initialize speech recognition
    initializeSpeechRecognition();

    // Restore saved text buffer on page load
    try {
      const savedText = localStorage.getItem(STORAGE_TEXT_KEY);
      if (savedText) {
        textArea.value = savedText;
      }
    } catch (e) {
      console.error('Error restoring text buffer:', e);
    }
      // After a short delay, ensure focus and cursor position again
    // (in case browser stole focus during page load)
    setTimeout(() => {
      textArea.focus();
    }, 1000);

    // After a short delay, ensure focus and cursor position again
    // (in case browser stole focus during page load)
    setTimeout(() => {
      textArea.setSelectionRange(0, 0);
    }, 1200);

    // Check URL parameter to auto-start mic dictation
    // Use a delay to ensure speech recognition is fully initialized
    function checkAutoMicStart() {
      const urlParams = new URLSearchParams(window.location.search);
      const micParam = urlParams.get('mic');
      if (micParam && micParam.toLowerCase() === 'on') {
        // Start mic dictation if not already listening and recognition is available
        if (!shouldKeepListening && supportsSpeechRecognition()) {
          toggleSpeechRecognition();
        }
      }
    }

    // Delay auto-mic start to ensure speech engine is initialized
    setTimeout(checkAutoMicStart, 1000);

    // Expose some helpers to console for debugging if needed (handy during development)
    window.__tts = {
      speakNow: (txt) => speakText(String(txt)),
      cancel: () => { if (supportsSpeech()) window.speechSynthesis.cancel(); }
    };
  </script>
</body>
</html>
